{"version":3,"file":"parse-nested-form-data.umd.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * @name parse-nested-form-data\n * @license MIT license.\n * @copyright (c) 2022 Christian Schurr\n * @author Christian Schurr <chris@schurr.dev>\n */\n\n/**\n * Thrown when a path is used multiple times or has missmatching path parts.\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'b')\n * formData.append('a[0]', 'c')\n * parseFormData(formData)\n * // throws DuplicateKeyError('a[0]')\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', 'b')\n * formData.append('a', 'c')\n * parseFormData(formData)\n * // throws DuplicateKeyError('a')\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', 'b')\n * formData.append('a[]', 'c')\n * parseFormData(formData)\n * // throws DuplicateKeyError('a[]')\n * ```\n *\n */\nexport class DuplicateKeyError extends Error {\n  key: string\n  constructor(key: string) {\n    super(`Duplicate key at path part ${key}`)\n    this.key = key\n  }\n}\n/**\n * Thrown when an array is used at the same path with an order parameter and\n * without an order parameter.\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'a')\n * formData.append('a[]', 'b')\n * parseFormData(formData)\n * // => throws `MixedArrayError(a[])`\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[]', 'a')\n * formData.append('a[0]', 'b')\n * parseFormData(formData)\n * // => throws `MixedArrayError(a[0])`\n * ```\n */\nexport class MixedArrayError extends Error {\n  key: string\n  constructor(key: string) {\n    super(`Mixed array at path part ${key}`)\n    this.key = key\n  }\n}\n\ntype JsonObject = {[Key in string]?: JsonValue}\ntype JsonArray = Array<JsonValue>\ntype JsonValue =\n  | string\n  | number\n  | JsonObject\n  | JsonArray\n  | boolean\n  | null\n  | File\ntype JsonLeafValue = Exclude<JsonValue, JsonArray | JsonObject>\n\nfunction isJsonObject(val: JsonValue): val is JsonObject {\n  return (\n    typeof val === 'object' &&\n    !Array.isArray(val) &&\n    val !== null &&\n    !(val instanceof File)\n  )\n}\n\n/**\n * Default Transformer for `parseFormData`.\n *\n * Transforms a FormData Entry into a path and a `JsonLeafValue`.\n *\n * - `path` starts with `+` -> transform value to `number`\n * - `path` starts with `&` -> transform value to `boolean`\n * - `path` starts with `-` -> transform value to `null`\n *\n * @example\n * ```ts\n * const entry = ['a[0]', 'b']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: 'b'}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['+a[0]', '1']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: 1}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['&a[0]', 'true']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: true}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['-a[0]', 'null']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: null}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['a[0]', new File([''], 'file.txt')]\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: File}\n * ```\n *\n *\n * @param entry [path, value]: the FormData entry\n * @returns the path and the transformed value\n */\nfunction defaultTransform(entry: [path: string, value: string | File]): {\n  path: string\n  value: JsonLeafValue\n} {\n  let path = entry[0]\n  let value: JsonLeafValue = entry[1]\n  if (path.startsWith('+')) {\n    path = path.slice(1)\n    value = Number(value)\n  } else if (path.startsWith('&')) {\n    path = path.slice(1)\n    value = value === 'on' || value === 'true' || Boolean(Number(value))\n  } else if (path.startsWith('-')) {\n    path = path.slice(1)\n    value = null\n  }\n  return {path, value}\n}\n\ntype DefaultTransform = typeof defaultTransform\n/**\n * Options to change the behavior of `parseFormData`.\n * @param transformEntry - a function to transform the FormData entry into a path and a value\n * (default: `defaultTransform`)\n * @param removeEmptyString - skip empty values '' (default: `false`)\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', '')\n * formData.append('b', 'b')\n * const result = parseFormData(formData, {removeEmptyString: true})\n * // => {b: 'b'}\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', 'a')\n * formData.append('b', 'b')\n * parseFormData(formData, {\n *   transformEntry: ([path, value], defaultTransform) => {\n *     return {\n *       path,\n *       value:\n *         typeof value === 'string'\n *           ? value.toUpperCase()\n *           : defaultTransform(value),\n *     }\n *   },\n * })\n * // => {a: 'A', b: 'B'}\n * ```\n */\nexport type ParseFormDataOptions = {\n  removeEmptyString?: boolean\n  transformEntry?: (\n    entry: [path: string, value: string | File],\n    defaultTransform: DefaultTransform,\n  ) => {path: string; value: JsonLeafValue}\n}\n\n/**\n * A parsed part of a FormData path. It consists of four parts:\n * @param path - the key to access the value in the intermediate result\n * @param type - the type of the path part (array - e.g. [\\d*], or object .e.g. .key)\n * @param default - the default value of the next path part ([] for array, {} for object)\n * @param pathToPart - the full path to the current path part\n *\n * @example\n * ```ts\n * const path = 'a[0].b'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: [], pathToPart: 'a'},\n * //     {path: '0', type: 'array', default: {}, pathToPart: 'a[0]'},\n * //     {path: 'b', type: 'object', default: {}, pathToPart: 'a[0].b'}]\n * ```\n */\ntype PathPart = {\n  path: string\n  type: 'object' | 'array'\n  default: {} | []\n  pathToPart: string\n}\n/**\n *\n * Transforms a FormData path into an array of `PathPart`s.\n *\n * @param path - the path to extract the path parts from\n * @returns {Array<PathPart>} the extracted path parts\n *\n * @example\n * ```ts\n * const path = 'a[0].b'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: [], pathToPart: 'a'},\n * //     {path: '0', type: 'array', default: {}, pathToPart: 'a[0]'},\n * //     {path: 'b', type: 'object', default: {}, pathToPart: 'a[0].b'}]\n * ```\n *\n * @example\n * ```ts\n * const path = 'a.b'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: {}, pathToPart: 'a'},\n * //     {path: 'b', type: 'object', default: {}, pathToPart: 'a.b'}]\n * ```\n *\n * @example\n * ```ts\n * const path = 'a[][0]'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: [], pathToPart: 'a'},\n * //     {path: '', type: 'array', default: [], pathToPart: 'a[]'},\n * //     {path: '0', type: 'array', default: {}, pathToPart: 'a[][0]'}]\n * ```\n *\n *\n */\nfunction extractPathParts(path: string): Array<PathPart> {\n  const re = /((?<array>\\d*)\\]|(?<pathPart>[^.[]+))(?<nextType>\\[|\\.|$)/g\n\n  return Array.from(path.matchAll(re)).map<PathPart>(match => {\n    // self casted RegexExpMatchArray to custom\n    const typedMatch = match as unknown as [string, string] &\n      RegExpExecArray & {\n        groups:\n          | {\n              pathPart: undefined\n              array: string\n              nextType: '[' | '.' | ''\n            }\n          | {\n              pathPart: string\n              array: undefined\n              nextType: '[' | '.' | ''\n            }\n      }\n    const {array, pathPart, nextType} = typedMatch.groups\n    const type = array === undefined ? 'object' : 'array'\n    const nextDefault = nextType === '[' ? [] : {}\n    return {\n      path: array ?? pathPart,\n      type,\n      default: nextDefault,\n      pathToPart: path.slice(0, typedMatch.index + typedMatch[1].length),\n    }\n  })\n}\n\n/**\n *\n * Returns the value accessed via `pathPart` in the `currentPathObject`\n * and a setter function to set the value in the `currentPathObject` via the\n * provided `pathPart`.\n *\n * @param pathPart - the path part to get the setter and getter for\n * @param currentPathObject - the object at the current path (before the path part)\n * @param arraysWithOrder - a set of arrays that have an order\n * @returns the setter and getter for the path part\n *\n * @example\n * ```ts\n * const pathPart = {path: 'a', type: 'object', default: {}, pathToPart: 'a'}\n * const currentPathObject = {}\n * const arraysWithOrder = new Set()\n * const [value, setValue] = getSetterAndGetter(pathPart, currentPathObject, arraysWithOrder)\n * setValue('b')\n * // => currentPathObject = {a: 'b'}\n * ```\n *\n * @example\n * ```ts\n * const pathPart = {path: '0', type: 'array', default: [], pathToPart: 'a[0]'}\n * const currentPathObject = {a: []}\n * const arraysWithOrder = new Set()\n * const [value, setValue] = getSetterAndGetter(pathPart, currentPathObject, arraysWithOrder)\n * setValue('b')\n * // => currentPathObject = {a: ['b']}\n * ```\n *\n */\nfunction handlePathPart(\n  pathPart: PathPart,\n  currentPathObject: JsonArray | JsonObject,\n  arraysWithOrder: Set<JsonArray>,\n): [\n  nextPathValue: JsonValue | undefined,\n  setNextPathValue: (value: JsonValue) => void,\n] {\n  if (pathPart.type === 'object') {\n    if (Array.isArray(currentPathObject)) {\n      throw new DuplicateKeyError(pathPart.pathToPart)\n    }\n    const currentObject = currentPathObject\n    return [\n      currentObject[pathPart.path],\n      val => (currentObject[pathPart.path] = val),\n    ]\n  }\n  if (!Array.isArray(currentPathObject)) {\n    throw new DuplicateKeyError(pathPart.pathToPart)\n  }\n  const currentArray = currentPathObject\n  const isOrdered = pathPart.path !== ''\n\n  const isOrderedArray = arraysWithOrder.has(currentArray)\n  if (isOrdered) {\n    arraysWithOrder.add(currentArray)\n  }\n  if (\n    (!isOrdered && isOrderedArray) ||\n    (isOrdered && !isOrderedArray && currentArray.length > 0)\n  ) {\n    throw new MixedArrayError(pathPart.pathToPart)\n  }\n\n  const order = isOrdered ? Number(pathPart.path) : currentArray.length\n  return [currentArray[order], val => (currentArray[order] = val)]\n}\n\n/**\n *\n * Parses a FormData object to a JSON object. This is done by parsing the `name`\n * attribute of each `FormDataEntryValue` and then inserting the value at the\n * path. Also by default the start of the path is used to transform the value.\n *\n *\n * In front of the whole `key`:\n *  - `+` => parse to `Number`\n *  - `-` => set value to `null`\n *  - `&` => parse to `Boolean`\n *\n * - `.` between path parts => nest into `objects`\n * - `[\\d*]` after path part => push to array in order `\\d` or push to end if `[]`\n *\n\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('+a', '1')\n * formData.append('&b', 'true')\n * formData.append('-c', 'null')\n * formData.append('d', 'foo')\n * parseFormData(formData, defaultTransform)\n * // => {a: 1, b: true, c: null, d: 'foo'}\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a.b', 'foo')\n * parseFormData(formData)\n * // => {a: {b: 'foo'}}\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'foo')\n * formData.append('a[1]', 'bar')\n * parseFormData(formData)\n * // => {a: ['foo', 'bar']}\n * ```\n * \n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[]', 'foo')\n * formData.append('a[]', 'bar')\n * parseFormData(formData)\n * // => {a: ['foo', 'bar']}\n * ```\n * \n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'foo')\n * parseFormData(formData, {transformEntry: (path, value) => {path, value: value + 'bar'}})\n * // => {a: ['foobar']}\n * ```\n * \n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'foo')\n * formData.append('a[1]', '')\n * parseFormData(formData, {removeEmptyString: true})\n * // => {a: ['foo']}\n * ```\n *\n * @param {Iterable<[string, string | File]>} formData - an iterator of an [`path`, `value`] tuple\n * - `path` := `^(\\+|\\-|\\&)?([^\\.]+?(\\[\\d*\\])*)(\\.[^\\.]+?(\\[\\d*\\])*)*$` (e.g. `+a[][1].b`)\n * - `value` := `string` or `File`\n * @param {ParseFormDataOptions} options - options for parsing the form data\n * - `transformEntry` - a function to transform the path and the value before\n *    inserting the value at the path in the resulting object (default: `defaultTransform`)\n * - `removeEmptyString` - if `true` removes all entries where the value is an empty string\n * @returns {JsonObject} the parsed JSON object\n * @throws `DuplicateKeyError` if\n * - a path part is an object and the path part is already defined as an object\n * - a path part is an array and the path part is already defined as an array\n * @throws `MixedArrayError` if at a specific path part an unordered array is \n * defined and at a later path part an ordered array is defined or vice versa\n * - e.g. `a[0]` and `a[]`\n * - e.g. `a[]` and `a[0]`\n */\nexport function parseFormData(\n  formData: Iterable<[string, string | File]>,\n  {\n    removeEmptyString = false,\n    transformEntry = defaultTransform,\n  }: ParseFormDataOptions = {},\n): JsonObject {\n  const result: JsonObject = {}\n\n  // all arrays we need to squash (in place) later\n  const arraysWithOrder: Set<Array<JsonValue>> = new Set()\n\n  for (const entry of Array.from(formData)) {\n    if (removeEmptyString && entry[1] === '') continue\n\n    const {path, value} = transformEntry(entry, defaultTransform)\n    const pathParts = extractPathParts(path)\n\n    let currentPathObject: JsonObject | JsonArray = result\n    pathParts.forEach((pathPart, idx) => {\n      const [nextPathValue, setNextPathValue] = handlePathPart(\n        pathPart,\n        currentPathObject,\n        arraysWithOrder,\n      )\n\n      if (pathParts.length - 1 === idx) {\n        if (nextPathValue !== undefined) {\n          throw new DuplicateKeyError(pathPart.pathToPart)\n        }\n        setNextPathValue(value)\n      } else {\n        if (\n          nextPathValue !== undefined &&\n          !isJsonObject(nextPathValue) &&\n          !Array.isArray(nextPathValue)\n        ) {\n          throw new DuplicateKeyError(pathPart.pathToPart)\n        }\n\n        const nextPathObject = nextPathValue ?? pathPart.default\n        currentPathObject = nextPathObject\n        setNextPathValue(nextPathObject)\n      }\n    })\n  }\n\n  for (const orderedArray of Array.from(arraysWithOrder)) {\n    // replace array with a squashed array\n    // array.flat(0) will remove all empty slots (e.g. [0, , 1] => [0, 1])\n    orderedArray.splice(0, orderedArray.length, ...orderedArray.flat(0))\n  }\n\n  return result\n}\n"],"names":["DuplicateKeyError","Error","constructor","key","MixedArrayError","isJsonObject","val","Array","isArray","File","defaultTransform","entry","path","value","startsWith","slice","Number","Boolean","extractPathParts","re","from","matchAll","map","match","typedMatch","array","pathPart","nextType","groups","type","undefined","nextDefault","default","pathToPart","index","length","handlePathPart","currentPathObject","arraysWithOrder","currentObject","currentArray","isOrdered","isOrderedArray","has","add","order","parseFormData","formData","_temp","removeEmptyString","transformEntry","result","Set","pathParts","forEach","idx","nextPathValue","setNextPathValue","nextPathObject","orderedArray","splice","flat"],"mappings":";;;;;;EAAA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACO,MAAMA,iBAAiB,SAASC,KAAK,CAAC;IAE3CC,WAAWA,CAACC,GAAW,EAAE;EACvB,IAAA,KAAK,CAAC,CAAA,2BAAA,EAA8BA,GAAG,CAAA,CAAE,CAAC,CAAA;EAAA,IAAA,IAAA,CAF5CA,GAAG,GAAA,KAAA,CAAA,CAAA;MAGD,IAAI,CAACA,GAAG,GAAGA,GAAG,CAAA;EAChB,GAAA;EACF,CAAA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACO,MAAMC,eAAe,SAASH,KAAK,CAAC;IAEzCC,WAAWA,CAACC,GAAW,EAAE;EACvB,IAAA,KAAK,CAAC,CAAA,yBAAA,EAA4BA,GAAG,CAAA,CAAE,CAAC,CAAA;EAAA,IAAA,IAAA,CAF1CA,GAAG,GAAA,KAAA,CAAA,CAAA;MAGD,IAAI,CAACA,GAAG,GAAGA,GAAG,CAAA;EAChB,GAAA;EACF,CAAA;EAcA,SAASE,YAAYA,CAACC,GAAc,EAAqB;IACvD,OACE,OAAOA,GAAG,KAAK,QAAQ,IACvB,CAACC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,IACnBA,GAAG,KAAK,IAAI,IACZ,EAAEA,GAAG,YAAYG,IAAI,CAAC,CAAA;EAE1B,CAAA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAASC,gBAAgBA,CAACC,KAA2C,EAGnE;EACA,EAAA,IAAIC,IAAI,GAAGD,KAAK,CAAC,CAAC,CAAC,CAAA;EACnB,EAAA,IAAIE,KAAoB,GAAGF,KAAK,CAAC,CAAC,CAAC,CAAA;EACnC,EAAA,IAAIC,IAAI,CAACE,UAAU,CAAC,GAAG,CAAC,EAAE;EACxBF,IAAAA,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,CAAA;EACpBF,IAAAA,KAAK,GAAGG,MAAM,CAACH,KAAK,CAAC,CAAA;KACtB,MAAM,IAAID,IAAI,CAACE,UAAU,CAAC,GAAG,CAAC,EAAE;EAC/BF,IAAAA,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,CAAA;EACpBF,IAAAA,KAAK,GAAGA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,MAAM,IAAII,OAAO,CAACD,MAAM,CAACH,KAAK,CAAC,CAAC,CAAA;KACrE,MAAM,IAAID,IAAI,CAACE,UAAU,CAAC,GAAG,CAAC,EAAE;EAC/BF,IAAAA,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,CAAA;EACpBF,IAAAA,KAAK,GAAG,IAAI,CAAA;EACd,GAAA;IACA,OAAO;MAACD,IAAI;EAAEC,IAAAA,KAAAA;KAAM,CAAA;EACtB,CAAA;;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EASA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAOA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAASK,gBAAgBA,CAACN,IAAY,EAAmB;IACvD,MAAMO,EAAE,GAAG,4DAA4D,CAAA;EAEvE,EAAA,OAAOZ,KAAK,CAACa,IAAI,CAACR,IAAI,CAACS,QAAQ,CAACF,EAAE,CAAC,CAAC,CAACG,GAAG,CAAWC,KAAK,IAAI;EAC1D;MACA,MAAMC,UAAU,GAAGD,KAahB,CAAA;MACH,MAAM;QAACE,KAAK;QAAEC,QAAQ;EAAEC,MAAAA,QAAAA;OAAS,GAAGH,UAAU,CAACI,MAAM,CAAA;MACrD,MAAMC,IAAI,GAAGJ,KAAK,KAAKK,SAAS,GAAG,QAAQ,GAAG,OAAO,CAAA;MACrD,MAAMC,WAAW,GAAGJ,QAAQ,KAAK,GAAG,GAAG,EAAE,GAAG,EAAE,CAAA;MAC9C,OAAO;QACLf,IAAI,EAAEa,KAAK,IAAIC,QAAQ;QACvBG,IAAI;EACJG,MAAAA,OAAO,EAAED,WAAW;EACpBE,MAAAA,UAAU,EAAErB,IAAI,CAACG,KAAK,CAAC,CAAC,EAAES,UAAU,CAACU,KAAK,GAAGV,UAAU,CAAC,CAAC,CAAC,CAACW,MAAM,CAAA;OAClE,CAAA;EACH,GAAC,CAAC,CAAA;EACJ,CAAA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAASC,cAAcA,CACrBV,QAAkB,EAClBW,iBAAyC,EACzCC,eAA+B,EAI/B;EACA,EAAA,IAAIZ,QAAQ,CAACG,IAAI,KAAK,QAAQ,EAAE;EAC9B,IAAA,IAAItB,KAAK,CAACC,OAAO,CAAC6B,iBAAiB,CAAC,EAAE;EACpC,MAAA,MAAM,IAAIrC,iBAAiB,CAAC0B,QAAQ,CAACO,UAAU,CAAC,CAAA;EAClD,KAAA;MACA,MAAMM,aAAa,GAAGF,iBAAiB,CAAA;EACvC,IAAA,OAAO,CACLE,aAAa,CAACb,QAAQ,CAACd,IAAI,CAAC,EAC5BN,GAAG,IAAKiC,aAAa,CAACb,QAAQ,CAACd,IAAI,CAAC,GAAGN,GAAI,CAC5C,CAAA;EACH,GAAA;EACA,EAAA,IAAI,CAACC,KAAK,CAACC,OAAO,CAAC6B,iBAAiB,CAAC,EAAE;EACrC,IAAA,MAAM,IAAIrC,iBAAiB,CAAC0B,QAAQ,CAACO,UAAU,CAAC,CAAA;EAClD,GAAA;IACA,MAAMO,YAAY,GAAGH,iBAAiB,CAAA;EACtC,EAAA,MAAMI,SAAS,GAAGf,QAAQ,CAACd,IAAI,KAAK,EAAE,CAAA;EAEtC,EAAA,MAAM8B,cAAc,GAAGJ,eAAe,CAACK,GAAG,CAACH,YAAY,CAAC,CAAA;EACxD,EAAA,IAAIC,SAAS,EAAE;EACbH,IAAAA,eAAe,CAACM,GAAG,CAACJ,YAAY,CAAC,CAAA;EACnC,GAAA;EACA,EAAA,IACG,CAACC,SAAS,IAAIC,cAAc,IAC5BD,SAAS,IAAI,CAACC,cAAc,IAAIF,YAAY,CAACL,MAAM,GAAG,CAAE,EACzD;EACA,IAAA,MAAM,IAAI/B,eAAe,CAACsB,QAAQ,CAACO,UAAU,CAAC,CAAA;EAChD,GAAA;EAEA,EAAA,MAAMY,KAAK,GAAGJ,SAAS,GAAGzB,MAAM,CAACU,QAAQ,CAACd,IAAI,CAAC,GAAG4B,YAAY,CAACL,MAAM,CAAA;EACrE,EAAA,OAAO,CAACK,YAAY,CAACK,KAAK,CAAC,EAAEvC,GAAG,IAAKkC,YAAY,CAACK,KAAK,CAAC,GAAGvC,GAAI,CAAC,CAAA;EAClE,CAAA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACO,SAASwC,aAAaA,CAC3BC,QAA2C,EAAAC,KAAA,EAK/B;IAAA,IAJZ;EACEC,IAAAA,iBAAiB,GAAG,KAAK;EACzBC,IAAAA,cAAc,GAAGxC,gBAAAA;EACG,GAAC,GAAAsC,KAAA,KAAA,KAAA,CAAA,GAAG,EAAE,GAAAA,KAAA,CAAA;IAE5B,MAAMG,MAAkB,GAAG,EAAE,CAAA;;EAE7B;EACA,EAAA,MAAMb,eAAsC,GAAG,IAAIc,GAAG,EAAE,CAAA;IAExD,KAAK,MAAMzC,KAAK,IAAIJ,KAAK,CAACa,IAAI,CAAC2B,QAAQ,CAAC,EAAE;MACxC,IAAIE,iBAAiB,IAAItC,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,SAAA;MAE1C,MAAM;QAACC,IAAI;EAAEC,MAAAA,KAAAA;EAAK,KAAC,GAAGqC,cAAc,CAACvC,KAAK,EAAED,gBAAgB,CAAC,CAAA;EAC7D,IAAA,MAAM2C,SAAS,GAAGnC,gBAAgB,CAACN,IAAI,CAAC,CAAA;MAExC,IAAIyB,iBAAyC,GAAGc,MAAM,CAAA;EACtDE,IAAAA,SAAS,CAACC,OAAO,CAAC,CAAC5B,QAAQ,EAAE6B,GAAG,KAAK;EACnC,MAAA,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGrB,cAAc,CACtDV,QAAQ,EACRW,iBAAiB,EACjBC,eACF,CAAC,CAAA;EAED,MAAA,IAAIe,SAAS,CAAClB,MAAM,GAAG,CAAC,KAAKoB,GAAG,EAAE;UAChC,IAAIC,aAAa,KAAK1B,SAAS,EAAE;EAC/B,UAAA,MAAM,IAAI9B,iBAAiB,CAAC0B,QAAQ,CAACO,UAAU,CAAC,CAAA;EAClD,SAAA;UACAwB,gBAAgB,CAAC5C,KAAK,CAAC,CAAA;EACzB,OAAC,MAAM;EACL,QAAA,IACE2C,aAAa,KAAK1B,SAAS,IAC3B,CAACzB,YAAY,CAACmD,aAAa,CAAC,IAC5B,CAACjD,KAAK,CAACC,OAAO,CAACgD,aAAa,CAAC,EAC7B;EACA,UAAA,MAAM,IAAIxD,iBAAiB,CAAC0B,QAAQ,CAACO,UAAU,CAAC,CAAA;EAClD,SAAA;EAEA,QAAA,MAAMyB,cAAc,GAAGF,aAAa,IAAI9B,QAAQ,CAACM,OAAO,CAAA;EACxDK,QAAAA,iBAAiB,GAAGqB,cAAc,CAAA;UAClCD,gBAAgB,CAACC,cAAc,CAAC,CAAA;EAClC,OAAA;EACF,KAAC,CAAC,CAAA;EACJ,GAAA;IAEA,KAAK,MAAMC,YAAY,IAAIpD,KAAK,CAACa,IAAI,CAACkB,eAAe,CAAC,EAAE;EACtD;EACA;EACAqB,IAAAA,YAAY,CAACC,MAAM,CAAC,CAAC,EAAED,YAAY,CAACxB,MAAM,EAAE,GAAGwB,YAAY,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;EACtE,GAAA;EAEA,EAAA,OAAOV,MAAM,CAAA;EACf;;;;;;;;;;;;"}