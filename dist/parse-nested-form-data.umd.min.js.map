{"version":3,"file":"parse-nested-form-data.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * @name parse-nested-form-data\n * @license MIT license.\n * @copyright (c) 2022 Christian Schurr\n * @author Christian Schurr <chris@schurr.dev>\n */\n\n/**\n * Thrown when a path is used multiple times or has missmatching path parts.\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'b')\n * formData.append('a[0]', 'c')\n * parseFormData(formData)\n * // throws DuplicateKeyError('a[0]')\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', 'b')\n * formData.append('a', 'c')\n * parseFormData(formData)\n * // throws DuplicateKeyError('a')\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', 'b')\n * formData.append('a[]', 'c')\n * parseFormData(formData)\n * // throws DuplicateKeyError('a[]')\n * ```\n *\n */\nexport class DuplicateKeyError extends Error {\n  key: string\n  constructor(key: string) {\n    super(`Duplicate key at path part ${key}`)\n    this.key = key\n  }\n}\n/**\n * Thrown when an array is used at the same path with an order parameter and\n * without an order parameter.\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'a')\n * formData.append('a[]', 'b')\n * parseFormData(formData)\n * // => throws `MixedArrayError(a[])`\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[]', 'a')\n * formData.append('a[0]', 'b')\n * parseFormData(formData)\n * // => throws `MixedArrayError(a[0])`\n * ```\n */\nexport class MixedArrayError extends Error {\n  key: string\n  constructor(key: string) {\n    super(`Mixed array at path part ${key}`)\n    this.key = key\n  }\n}\n\ntype JsonObject = {[Key in string]?: JsonValue}\ntype JsonArray = Array<JsonValue>\ntype JsonValue =\n  | string\n  | number\n  | JsonObject\n  | JsonArray\n  | boolean\n  | null\n  | File\ntype JsonLeafValue = Exclude<JsonValue, JsonArray | JsonObject>\n\nfunction isJsonObject(val: JsonValue): val is JsonObject {\n  return (\n    typeof val === 'object' &&\n    !Array.isArray(val) &&\n    val !== null &&\n    !(val instanceof File)\n  )\n}\n\n/**\n * Default Transformer for `parseFormData`.\n *\n * Transforms a FormData Entry into a path and a `JsonLeafValue`.\n *\n * - `path` starts with `+` -> transform value to `number`\n * - `path` starts with `&` -> transform value to `boolean`\n * - `path` starts with `-` -> transform value to `null`\n *\n * @example\n * ```ts\n * const entry = ['a[0]', 'b']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: 'b'}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['+a[0]', '1']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: 1}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['&a[0]', 'true']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: true}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['-a[0]', 'null']\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: null}\n * ```\n *\n * @example\n * ```ts\n * const entry = ['a[0]', new File([''], 'file.txt')]\n * const result = defaultTransform(entry)\n * // => {path: 'a[0]', value: File}\n * ```\n *\n *\n * @param entry [path, value]: the FormData entry\n * @returns the path and the transformed value\n */\nfunction defaultTransform(entry: [path: string, value: string | File]): {\n  path: string\n  value: JsonLeafValue\n} {\n  let path = entry[0]\n  let value: JsonLeafValue = entry[1]\n  if (path.startsWith('+')) {\n    path = path.slice(1)\n    value = Number(value)\n  } else if (path.startsWith('&')) {\n    path = path.slice(1)\n    value = value === 'on' || value === 'true' || Boolean(Number(value))\n  } else if (path.startsWith('-')) {\n    path = path.slice(1)\n    value = null\n  }\n  return {path, value}\n}\n\ntype DefaultTransform = typeof defaultTransform\n/**\n * Options to change the behavior of `parseFormData`.\n * @param transformEntry - a function to transform the FormData entry into a path and a value\n * (default: `defaultTransform`)\n * @param removeEmptyString - skip empty values '' (default: `false`)\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', '')\n * formData.append('b', 'b')\n * const result = parseFormData(formData, {removeEmptyString: true})\n * // => {b: 'b'}\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a', 'a')\n * formData.append('b', 'b')\n * parseFormData(formData, {\n *   transformEntry: ([path, value], defaultTransform) => {\n *     return {\n *       path,\n *       value:\n *         typeof value === 'string'\n *           ? value.toUpperCase()\n *           : defaultTransform(value),\n *     }\n *   },\n * })\n * // => {a: 'A', b: 'B'}\n * ```\n */\nexport type ParseFormDataOptions = {\n  removeEmptyString?: boolean\n  transformEntry?: (\n    entry: [path: string, value: string | File],\n    defaultTransform: DefaultTransform,\n  ) => {path: string; value: JsonLeafValue}\n}\n\n/**\n * A parsed part of a FormData path. It consists of four parts:\n * @param path - the key to access the value in the intermediate result\n * @param type - the type of the path part (array - e.g. [\\d*], or object .e.g. .key)\n * @param default - the default value of the next path part ([] for array, {} for object)\n * @param pathToPart - the full path to the current path part\n *\n * @example\n * ```ts\n * const path = 'a[0].b'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: [], pathToPart: 'a'},\n * //     {path: '0', type: 'array', default: {}, pathToPart: 'a[0]'},\n * //     {path: 'b', type: 'object', default: {}, pathToPart: 'a[0].b'}]\n * ```\n */\ntype PathPart = {\n  path: string\n  type: 'object' | 'array'\n  default: {} | []\n  pathToPart: string\n}\n/**\n *\n * Transforms a FormData path into an array of `PathPart`s.\n *\n * @param path - the path to extract the path parts from\n * @returns {Array<PathPart>} the extracted path parts\n *\n * @example\n * ```ts\n * const path = 'a[0].b'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: [], pathToPart: 'a'},\n * //     {path: '0', type: 'array', default: {}, pathToPart: 'a[0]'},\n * //     {path: 'b', type: 'object', default: {}, pathToPart: 'a[0].b'}]\n * ```\n *\n * @example\n * ```ts\n * const path = 'a.b'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: {}, pathToPart: 'a'},\n * //     {path: 'b', type: 'object', default: {}, pathToPart: 'a.b'}]\n * ```\n *\n * @example\n * ```ts\n * const path = 'a[][0]'\n * const result = extractPathParts(path)\n * // => [{path: 'a', type: 'object, default: [], pathToPart: 'a'},\n * //     {path: '', type: 'array', default: [], pathToPart: 'a[]'},\n * //     {path: '0', type: 'array', default: {}, pathToPart: 'a[][0]'}]\n * ```\n *\n *\n */\nfunction extractPathParts(path: string): Array<PathPart> {\n  const re = /((?<array>\\d*)\\]|(?<pathPart>[^.[]+))(?<nextType>\\[|\\.|$)/g\n\n  return Array.from(path.matchAll(re)).map<PathPart>(match => {\n    // self casted RegexExpMatchArray to custom\n    const typedMatch = match as unknown as [string, string] &\n      RegExpExecArray & {\n        groups:\n          | {\n              pathPart: undefined\n              array: string\n              nextType: '[' | '.' | ''\n            }\n          | {\n              pathPart: string\n              array: undefined\n              nextType: '[' | '.' | ''\n            }\n      }\n    const {array, pathPart, nextType} = typedMatch.groups\n    const type = array === undefined ? 'object' : 'array'\n    const nextDefault = nextType === '[' ? [] : {}\n    return {\n      path: array ?? pathPart,\n      type,\n      default: nextDefault,\n      pathToPart: path.slice(0, typedMatch.index + typedMatch[1].length),\n    }\n  })\n}\n\n/**\n *\n * Returns the value accessed via `pathPart` in the `currentPathObject`\n * and a setter function to set the value in the `currentPathObject` via the\n * provided `pathPart`.\n *\n * @param pathPart - the path part to get the setter and getter for\n * @param currentPathObject - the object at the current path (before the path part)\n * @param arraysWithOrder - a set of arrays that have an order\n * @returns the setter and getter for the path part\n *\n * @example\n * ```ts\n * const pathPart = {path: 'a', type: 'object', default: {}, pathToPart: 'a'}\n * const currentPathObject = {}\n * const arraysWithOrder = new Set()\n * const [value, setValue] = getSetterAndGetter(pathPart, currentPathObject, arraysWithOrder)\n * setValue('b')\n * // => currentPathObject = {a: 'b'}\n * ```\n *\n * @example\n * ```ts\n * const pathPart = {path: '0', type: 'array', default: [], pathToPart: 'a[0]'}\n * const currentPathObject = {a: []}\n * const arraysWithOrder = new Set()\n * const [value, setValue] = getSetterAndGetter(pathPart, currentPathObject, arraysWithOrder)\n * setValue('b')\n * // => currentPathObject = {a: ['b']}\n * ```\n *\n */\nfunction handlePathPart(\n  pathPart: PathPart,\n  currentPathObject: JsonArray | JsonObject,\n  arraysWithOrder: Set<JsonArray>,\n): [\n  nextPathValue: JsonValue | undefined,\n  setNextPathValue: (value: JsonValue) => void,\n] {\n  if (pathPart.type === 'object') {\n    if (Array.isArray(currentPathObject)) {\n      throw new DuplicateKeyError(pathPart.pathToPart)\n    }\n    const currentObject = currentPathObject\n    return [\n      currentObject[pathPart.path],\n      val => (currentObject[pathPart.path] = val),\n    ]\n  }\n  if (!Array.isArray(currentPathObject)) {\n    throw new DuplicateKeyError(pathPart.pathToPart)\n  }\n  const currentArray = currentPathObject\n  const isOrdered = pathPart.path !== ''\n\n  const isOrderedArray = arraysWithOrder.has(currentArray)\n  if (isOrdered) {\n    arraysWithOrder.add(currentArray)\n  }\n  if (\n    (!isOrdered && isOrderedArray) ||\n    (isOrdered && !isOrderedArray && currentArray.length > 0)\n  ) {\n    throw new MixedArrayError(pathPart.pathToPart)\n  }\n\n  const order = isOrdered ? Number(pathPart.path) : currentArray.length\n  return [currentArray[order], val => (currentArray[order] = val)]\n}\n\n/**\n *\n * Parses a FormData object to a JSON object. This is done by parsing the `name`\n * attribute of each `FormDataEntryValue` and then inserting the value at the\n * path. Also by default the start of the path is used to transform the value.\n *\n *\n * In front of the whole `key`:\n *  - `+` => parse to `Number`\n *  - `-` => set value to `null`\n *  - `&` => parse to `Boolean`\n *\n * - `.` between path parts => nest into `objects`\n * - `[\\d*]` after path part => push to array in order `\\d` or push to end if `[]`\n *\n\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('+a', '1')\n * formData.append('&b', 'true')\n * formData.append('-c', 'null')\n * formData.append('d', 'foo')\n * parseFormData(formData, defaultTransform)\n * // => {a: 1, b: true, c: null, d: 'foo'}\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a.b', 'foo')\n * parseFormData(formData)\n * // => {a: {b: 'foo'}}\n * ```\n *\n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'foo')\n * formData.append('a[1]', 'bar')\n * parseFormData(formData)\n * // => {a: ['foo', 'bar']}\n * ```\n * \n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[]', 'foo')\n * formData.append('a[]', 'bar')\n * parseFormData(formData)\n * // => {a: ['foo', 'bar']}\n * ```\n * \n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'foo')\n * parseFormData(formData, {transformEntry: (path, value) => {path, value: value + 'bar'}})\n * // => {a: ['foobar']}\n * ```\n * \n * @example\n * ```ts\n * const formData = new FormData()\n * formData.append('a[0]', 'foo')\n * formData.append('a[1]', '')\n * parseFormData(formData, {removeEmptyString: true})\n * // => {a: ['foo']}\n * ```\n *\n * @param {Iterable<[string, string | File]>} formData - an iterator of an [`path`, `value`] tuple\n * - `path` := `^(\\+|\\-|\\&)?([^\\.]+?(\\[\\d*\\])*)(\\.[^\\.]+?(\\[\\d*\\])*)*$` (e.g. `+a[][1].b`)\n * - `value` := `string` or `File`\n * @param {ParseFormDataOptions} options - options for parsing the form data\n * - `transformEntry` - a function to transform the path and the value before\n *    inserting the value at the path in the resulting object (default: `defaultTransform`)\n * - `removeEmptyString` - if `true` removes all entries where the value is an empty string\n * @returns {JsonObject} the parsed JSON object\n * @throws `DuplicateKeyError` if\n * - a path part is an object and the path part is already defined as an object\n * - a path part is an array and the path part is already defined as an array\n * @throws `MixedArrayError` if at a specific path part an unordered array is \n * defined and at a later path part an ordered array is defined or vice versa\n * - e.g. `a[0]` and `a[]`\n * - e.g. `a[]` and `a[0]`\n */\nexport function parseFormData(\n  formData: Iterable<[string, string | File]>,\n  {\n    removeEmptyString = false,\n    transformEntry = defaultTransform,\n  }: ParseFormDataOptions = {},\n): JsonObject {\n  const result: JsonObject = {}\n\n  // all arrays we need to squash (in place) later\n  const arraysWithOrder: Set<Array<JsonValue>> = new Set()\n\n  for (const entry of Array.from(formData)) {\n    if (removeEmptyString && entry[1] === '') continue\n\n    const {path, value} = transformEntry(entry, defaultTransform)\n    const pathParts = extractPathParts(path)\n\n    let currentPathObject: JsonObject | JsonArray = result\n    pathParts.forEach((pathPart, idx) => {\n      const [nextPathValue, setNextPathValue] = handlePathPart(\n        pathPart,\n        currentPathObject,\n        arraysWithOrder,\n      )\n\n      if (pathParts.length - 1 === idx) {\n        if (nextPathValue !== undefined) {\n          throw new DuplicateKeyError(pathPart.pathToPart)\n        }\n        setNextPathValue(value)\n      } else {\n        if (\n          nextPathValue !== undefined &&\n          !isJsonObject(nextPathValue) &&\n          !Array.isArray(nextPathValue)\n        ) {\n          throw new DuplicateKeyError(pathPart.pathToPart)\n        }\n\n        const nextPathObject = nextPathValue ?? pathPart.default\n        currentPathObject = nextPathObject\n        setNextPathValue(nextPathObject)\n      }\n    })\n  }\n\n  for (const orderedArray of Array.from(arraysWithOrder)) {\n    // replace array with a squashed array\n    // array.flat(0) will remove all empty slots (e.g. [0, , 1] => [0, 1])\n    orderedArray.splice(0, orderedArray.length, ...orderedArray.flat(0))\n  }\n\n  return result\n}\n"],"names":["DuplicateKeyError","Error","constructor","key","super","this","MixedArrayError","defaultTransform","entry","path","value","startsWith","slice","Number","Boolean","extractPathParts","Array","from","matchAll","map","match","typedMatch","array","pathPart","nextType","groups","type","undefined","default","pathToPart","index","length","handlePathPart","currentPathObject","arraysWithOrder","isArray","currentObject","val","currentArray","isOrdered","isOrderedArray","has","add","order","formData","_temp","removeEmptyString","transformEntry","result","Set","pathParts","forEach","idx","nextPathValue","setNextPathValue","File","nextPathObject","orderedArray","splice","flat"],"mappings":"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"}